<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tec | 陋室]]></title>
  <link href="http://wanax.github.io/blog/categories/tec/atom.xml" rel="self"/>
  <link href="http://wanax.github.io/"/>
  <updated>2013-09-29T20:37:41+08:00</updated>
  <id>http://wanax.github.io/</id>
  <author>
    <name><![CDATA[Wanax]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UIView三种动画笔记]]></title>
    <link href="http://wanax.github.io/blog/2013/06/09/uiviewsan-chong-dong-hua-bi-ji/"/>
    <updated>2013-06-09T10:30:00+08:00</updated>
    <id>http://wanax.github.io/blog/2013/06/09/uiviewsan-chong-dong-hua-bi-ji</id>
    <content type="html"><![CDATA[<pre><code>[UIView animateWithDuration:0.6f  
                          delay:0  
                        options:UIViewAnimationOptionCurveEaseOut  
                     animations:^{  
                         self.view.alpha = 0;  
                     }  
                     completion:^(BOOL finished) {  
                         [self.view removeFromSuperview];  
                     }];  
</code></pre>

<p>  <!--more--></p>

<pre><code>[UIView beginAnimations:@"animation" context:nil];  
[UIView setAnimationDuration:0.8f];  
[UIView setAnimationCurve:UIViewAnimationCurveEaseOut];  
[UIView setAnimationTransition:UIViewAnimationTransitionCurlDown forView:delegate.tabBarController.view cache:YES];  
[UIView commitAnimations];  



CATransition *animation = [CATransition animation];  
    animation.duration = 0.8f;  
    /*动画时间控制      
 UIViewAnimationCurveEaseInOut,         // slow at beginning and end      
 UIViewAnimationCurveEaseIn,            // slow at beginning      
 UIViewAnimationCurveEaseOut,           // slow at end     
 UIViewAnimationCurveLinear      
 */  
animation.timingFunction = UIViewAnimationCurveEaseInOut;  
animation.fillMode = kCAFillModeForwards;  
/*动画类型      
 kCATransitionFade;      
 kCATransitionMoveIn;      
 kCATransitionPush;      
 kCATransitionReveal;      
 */  
animation.type = kCATransitionMoveIn;  
/*动画进入方式      
 kCATransitionFromRight;      
 kCATransitionFromLeft; 
 kCATransitionFromTop; 
 kCATransitionFromBottom; 
 */  
animation.subtype = kCATransitionFromBottom;  
[[self.view layer] addAnimation:animation forKey:@"animation"];  
animation=nil; 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS上js引擎的使用]]></title>
    <link href="http://wanax.github.io/blog/2013/06/07/iosshang-jsyin-qing-de-shi-yong/"/>
    <updated>2013-06-07T11:47:00+08:00</updated>
    <id>http://wanax.github.io/blog/2013/06/07/iosshang-jsyin-qing-de-shi-yong</id>
    <content type="html"><![CDATA[<p> 如上篇文章所述ios折线图绘制，公司开发需要要用到一些字符串转公式的需求。自己实在有点惧自己写语法书啥的听公司大牛说可以使用js引擎试试，于是就抱着试试的态度调研了一把，感觉还不错。</p>

<p>这次试用了两个js引擎，一个是javascriptcore，这个比较方便可以直接引入便使用，另一个是google的v8引擎，这个有点麻烦要先编译通过才行，搞了好一阵才派上用场~倒是学到了好多新知识，哈哈。</p>

<!--more-->


<p>先说简单的javascriptcore吧，下载好库引入静态链接库和头文件便可以了。这里有时候会报错说找不到文件。google了一下发下一般是因为xcode本身对外来拷贝文件没有正确引用导致的，解决办法很简单，进入Build Phases 的Compile Source对新添加的头文件进行引用就好了。</p>

<p><img src="http://i1001.photobucket.com/albums/af134/mxiaochi/blogsource/20130607111925093_zps428cacd3.png" alt="image" /></p>

<p>接下来便是怎样使用的问题。</p>

<p>先在头文件里引用文件：</p>

<pre><code>import "JavaScriptCore/JavaScriptCore.h" 
</code></pre>

<p>然后是构造js的上下文context，这个还蛮重要的东西，具体的原理大家可以自行google，因为我自己理解的也很肤浅，略知皮毛而已。</p>

<pre><code>context = JSGlobalContextCreate(NULL);  
</code></pre>

<p>完了以后我把js运行的方法封装成了一个方法，如下：</p>

<pre><code>- (NSString *)runsJS:(NSString *)aJSString  
{  
    if (!aJSString) {  
        NSLog(@"[JSC] JS String is empty!");  
        return nil;  
    }  


JSStringRef scriptJS = JSStringCreateWithUTF8CString([aJSString UTF8String]);  
JSValueRef exception = NULL;  

JSValueRef result = JSEvaluateScript(context, scriptJS, NULL, NULL, 0, &amp;exception);  
NSString *res = nil;  

JSStringRef jstrArg = JSValueToStringCopy(context, result, NULL);  
res = (NSString*)JSStringCopyCFString(kCFAllocatorDefault, jstrArg);  

JSStringRelease(jstrArg);  

JSStringRelease(scriptJS);  

return res;  }  
</code></pre>

<p>封装完毕便可以顺利使用啦：</p>

<pre><code>NSString *str=[self.engine runJS:@"var str='';for(var i=0;i&lt;2;i++){str= str + '\\n' + i + ' :Hello' + ', World!';}"];  
    //NSLog(@"%@",str);  
</code></pre>

<p>这便是大体的javascriptcore的使用方法了。</p>

<p>接下来是v8引擎。</p>

<p>v8引擎的编译很痛苦，网上一般比较常见的教程是编译成动态库，lib之类的，但苹果貌似只让用.a的静态库，无形中又增加了负担。我网上搜了好多编译的方法，无非都是些svn check下v8的文件，然后安装python和对应python的一个编译工具scons进行编译。看攻略说，google先在又不提倡用scons了，又开发了另外一种东西&hellip;.真是能折腾。</p>

<p>我遇到的主要问题是好像编译的时候要搭配一个叫breakpad的东西一起，而这玩意儿又死活装不了，就一直卡在那里了。但比较意外的是最后经竟意外发现在v8根目录还有个make的命令，也可以直接编译&hellip;..就这样稀里糊涂的把静态库给整出来了，还隐藏得很深，search了一下才发现在哪里。</p>

<p><img src="http://i1001.photobucket.com/albums/af134/mxiaochi/blogsource/20130607113710843_zpsd81cc322.png" alt="image" /></p>

<p>这便是粗略的使用方法啦。</p>

<blockquote><p>一个简单的示例</p></blockquote>

<pre><code>var test=function(){  
var val=[];  
val["1.0"]=1;  
val["1.1"]=2;  
val["1.2"]=3;  
val["1.3"]=4;  
val["2"]=34;  

var str="var v=this.val; v[\"1.3\"]=v[\"1.0\"]*v[\"1.2\"];";  
var fun=new Function(str);  
val["0"]=5;  
fun();  
return val;  
}  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之使用CorePlot绘制折线图并添加拖动功能]]></title>
    <link href="http://wanax.github.io/blog/2013/06/07/ioskai-fa-zhi-shi-yong-coreplothui-zhi-zhe-xian-tu-bing-tian-jia-tuo-dong-gong-neng/"/>
    <updated>2013-06-07T11:06:00+08:00</updated>
    <id>http://wanax.github.io/blog/2013/06/07/ioskai-fa-zhi-shi-yong-coreplothui-zhi-zhe-xian-tu-bing-tian-jia-tuo-dong-gong-neng</id>
    <content type="html"><![CDATA[<p>做ios开发快两个月了 从基本的语法开始学起看看这个学学那个的。一开始对delegate controller view各种头大，就老老实实地跟着入门教程一步步的来。所幸之前做了一年多的java开发，熟悉了eclipse的界面和Deja的字体，换到mac下面用xcode也觉得很新鲜。</p>

<!--more-->


<p>感觉做ios开发这一块对内存管理要求还是不低的，因为之前做java，对这一块基本不怎么关心，突然转到ios上的时候在内存管理上还是犯过几次错误的。开始学习的时候看书上说谁创建谁释放，就简单的以为但凡创建出来的对象都要显式地去release，后来果然出过一次诡异的错误，修正之后对内存管理就更加用心地去学习了，这一块有时间后面再讨论，现在先把这几天对coreplot的使用记录一下，以备后用。</p>

<p>公司的需求是对数据解析进行折线图绘制，并且用户可以通过触摸调整数据点通过公式计算使折线图重新绘制。数据与公式都是服务器端获取的并且是打包成了一个json的字符串。这里面还牵扯到了字符串解析成公式的问题。上网搜了下，oc下并没有很好的解决方案，像这样做的话似乎只能自己写方法，让我想起了上学时候学编译原理写过的语法树，满满的都是泪啊~妥妥的能不写就不写。后来公司大牛说有js引擎可以拿过来用，因为公司这边也有做网页端的折线图绘制，在js下公式转换异常简单</p>

<pre><code>var fun=new fun(str);  
fun();  
</code></pre>

<p>如上所示，两行代码就把str代表的字符串公式解析并计算一遍了，实在是太无解了，妥妥必须使用，这个东西下篇文章再讲吧。
图像绘制的话google出来ios上比较常用的是CorePlot和PowerPlot，看了下两者的用法，感觉CorePlot会使用更多的代理之类的东西，感觉比较符合苹果的编码思路，就选了它来用了。</p>

<p>首先是下载coreplot库，把.a文件和头文件引入，这里就不赘述了。</p>

<p>先在头文件里定义几个后面要用到的量</p>

<pre><code>//转换坐标系字典，与手指触摸点匹配  
@property (nonatomic,retain) NSMutableDictionary *reverseDic;  
//js引擎上下文  
@property (nonatomic) JSGlobalContextRef context;  
//绘图view  
@property (nonatomic,retain) CPTGraphHostingView *hostView;  

//坐标转换方法，实际坐标转化相对坐标  
- (CGPoint)CoordinateTransformRealToAbstract:(CGPoint)point;  
//坐标转换方法，相对坐标转化实际坐标  
- (CGPoint)CoordinateTransformAbstractToReal:(CGPoint)point;  
//判断手指触摸点是否在折点旁边  
-(BOOL)isNearByThePoint:(CGPoint)p;  

//js代码运行  
- (NSString *)runsJS:(NSString *)aJSString; 
</code></pre>

<p>因为要对图像上的折点拖动，而我没有找到合适的对点的事件绑定方法，所以先直接对整个view进行手势监听，通过实际坐标与坐标轴坐标相对转换来判定触摸点是否是在折点附近已达到合理拖动的目的。</p>

<p>接下来便开始.m文件的编码工作啦。我先定义一个简单的折线图公式，y=x+n；把一些数据点塞到point数组里，做后面的datasource。接下来便是折线图的绘制，代码注释写得比较清楚，就不一一赘述了。值得注意的是，这里点的绘制也是使用ios里常用的datasource的方法，所以先别急着找那一系列点出现在哪里~</p>

<pre><code>- (void)viewDidLoad  
{  
    [super viewDidLoad];  
    UIButton *bt=[[UIButton alloc] init];  
    [self.view addSubview:bt];  
    points=[[NSMutableArray alloc] init];  
    reverseDic=[[NSMutableDictionary alloc] init];  
    NSUInteger i;  
    for(i=0;i&lt;NUM;i++){  
        id x=[NSNumber numberWithFloat:0+i];  
        id y=[NSNumber numberWithFloat:3*i];  
        [reverseDic setObject:y forKey:[NSString stringWithFormat:@"%.0f",[x floatValue]]];  
        [points addObject:[NSMutableDictionary dictionaryWithObjectsAndKeys:x,@"x",y,@"y",nil]];  
    }  
    // Do any additional setup after loading the view.  
    //初始化图形视图  
    graph=[[CPTXYGraph alloc] initWithFrame:CGRectZero];  
    CPTTheme *theme=[CPTTheme themeNamed:kCPTDarkGradientTheme];  
    [graph applyTheme:theme];  
    self . view =[[ CPTGraphHostingView alloc ] initWithFrame :[ UIScreen mainScreen ]. bounds ];  
    hostView=(CPTGraphHostingView *)self.view;  

    [hostView setHostedGraph : graph ];  

    NSLog(@"orgin:%.2f,%.2f",hostView.frame.origin.x,hostView.frame.origin.y);  
    NSLog(@"size:%.2f,%.2f",hostView.frame.size.height,hostView.frame.size.width);  

    // CPGraph 四边不留白  
    graph . paddingLeft = 0.0f ;  
    graph . paddingRight = 0.0f ;  
    graph . paddingTop = 0.0f ;  
    graph . paddingBottom = GRAPAHBOTTOMPAD ;  
    // 绘图区 4 边留白  
    graph . plotAreaFrame . paddingLeft = 0.0 ;  
    graph . plotAreaFrame . paddingTop = 0.0 ;  
    graph . plotAreaFrame . paddingRight = 0.0 ;  
    graph . plotAreaFrame . paddingBottom = 00.0 ;  






    //绘制图形空间  
    CPTXYPlotSpace *plotSpace=(CPTXYPlotSpace *)graph.defaultPlotSpace;  
    //plotSpace.allowsUserInteraction=YES;  

    //设置x，y坐标范围  
    plotSpace.xRange=[CPTPlotRange plotRangeWithLocation:  
                      CPTDecimalFromCGFloat(XRANGEBEGIN)  
                                                  length:CPTDecimalFromCGFloat(XRANGELENGTH)];  
    plotSpace.yRange=[CPTPlotRange plotRangeWithLocation:  
                      CPTDecimalFromCGFloat(YRANGEBEGIN)  length:CPTDecimalFromCGFloat(YRANGELENGTH)];  

    //绘制坐标系  
    CPTXYAxisSet *axisSet=(CPTXYAxisSet *)graph.axisSet;  
    CPTXYAxis *x=axisSet.xAxis;  

    CPTMutableLineStyle *lineStyle = [CPTMutableLineStyle lineStyle];  
    lineStyle.miterLimit = 1.0f;  
    lineStyle.lineWidth = 2.0;  
    lineStyle.lineColor = [CPTColor colorWithComponentRed:255/255.0 green:211/255.0 blue:155/255.0 alpha:1.0];  

    x.majorIntervalLength=CPTDecimalFromFloat(XINTERVALLENGTH);  
    x.orthogonalCoordinateDecimal=CPTDecimalFromFloat(XORTHOGONALCOORDINATE);  
    x.minorTicksPerInterval=XTICKSPERINTERVAL;  
    x.minorTickLineStyle = lineStyle;  

    CPTXYAxis *y=axisSet.yAxis;  
    y.majorIntervalLength=CPTDecimalFromFloat(YINTERVALLENGTH);  
    y.orthogonalCoordinateDecimal=CPTDecimalFromFloat(YORTHOGONALCOORDINATE);  
    y.minorTicksPerInterval=YTICKSPERINTERVAL;  
    y.minorTickLineStyle = lineStyle;  


    y. labelingPolicy = CPTAxisLabelingPolicyNone ;  


    //修改折线图线段样式  
    CPTScatterPlot *boundLinePlot=[[[CPTScatterPlot alloc] init] autorelease];  
    //CPTMutableLineStyle *lineStyle=[CPTMutableLineStyle lineStyle];  
    lineStyle.miterLimit=2.0f;  
    lineStyle.lineWidth=2.0f;  
    lineStyle.lineColor=[CPTColor whiteColor];  
    boundLinePlot.dataLineStyle=lineStyle;  
    boundLinePlot.identifier=@"Blue Plot";  
    boundLinePlot.dataSource=self;//需实现委托  



    // Do a red-blue gradient: 渐变色区域  
    //  
    /*CPTColor * blueColor        = [CPTColor colorWithComponentRed:0.3 green:0.3 blue:1.0 alpha:0.8]; 
    CPTColor * redColor         = [CPTColor colorWithComponentRed:1.0 green:0.3 blue:0.3 alpha:0.8]; 
    CPTGradient * areaGradient1 = [CPTGradient gradientWithBeginningColor:blueColor 
                                                              endingColor:redColor]; 
    areaGradient1.angle = -120.0f; 
    CPTFill * areaGradientFill  = [CPTFill fillWithGradient:areaGradient1]; 
    boundLinePlot.areaFill      = areaGradientFill; 
    boundLinePlot.areaBaseValue = [[NSDecimalNumber numberWithFloat:0.5] decimalValue]; // 渐变色的起点位置 
    */  


    // Add plot symbols: 表示数值的符号的形状  
    //  
    CPTMutableLineStyle * symbolLineStyle = [CPTMutableLineStyle lineStyle];  
    symbolLineStyle.lineColor = [CPTColor colorWithComponentRed:102/255.0 green:204/255.0 blue:255/255.0 alpha:1.0];  
    symbolLineStyle.lineWidth = 2.0;  

    CPTPlotSymbol * plotSymbol = [CPTPlotSymbol ellipsePlotSymbol];  
    //plotSymbol.fill          = [CPTFill fillWithColor: [CPTColor colorWithComponentRed:102/255.0 green:204/255.0 blue:255/255.0 alpha:1.0]];  
    plotSymbol.lineStyle     = symbolLineStyle;  
    plotSymbol.size          = CGSizeMake(1.8, 1.8);  
    boundLinePlot.plotSymbol = plotSymbol;  


    // Animate in the new plot: 淡入动画  
    boundLinePlot.opacity = 0.0f;  

    CABasicAnimation *fadeInAnimation = [CABasicAnimation animationWithKeyPath:@"opacity"];  
    fadeInAnimation.duration            = 3.0f;  
    fadeInAnimation.removedOnCompletion = NO;  
    fadeInAnimation.fillMode            = kCAFillModeForwards;  
    fadeInAnimation.toValue             = [NSNumber numberWithFloat:1.0];  
    [boundLinePlot addAnimation:fadeInAnimation forKey:@"shadowOffset"];  



    [graph addPlot:boundLinePlot];  


    //手势添加  
    UIPanGestureRecognizer *panGr=[[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(viewPan:)];  
    [hostView addGestureRecognizer:panGr];  
    [panGr release];  




    //NSString *str=[self.engine runJS:@"var str='';for(var i=0;i&lt;2;i++){str= str + '\\n' + i + ' :Hello' + ', World!';}"];  
    //NSLog(@"%@",str);  




} 
</code></pre>

<h3>这样一个初步的折现图便绘制完毕啦。数据源委托和数据标签的实现如下：</h3>

<pre><code>// 添加数据标签  
-( CPTLayer *)dataLabelForPlot:( CPTPlot *)plot recordIndex:( NSUInteger )index  
{  
    // 定义一个白色的 TextStyle  
    static CPTMutableTextStyle *whiteText = nil ;  
    if ( !whiteText ) {  
        whiteText = [[ CPTMutableTextStyle alloc ] init ];  
        whiteText.color=[CPTColor colorWithComponentRed:152/255.0 green:251/255.0 blue:152/255.0 alpha:1.0];  
    }  

    // 定义一个 TextLayer  
    CPTTextLayer *newLayer = nil ;  
    NSString * identifier=( NSString *)[plot identifier];  
    if ([identifier isEqualToString : @"Blue Plot" ]) {  

        newLayer=[[[CPTTextLayer alloc] initWithText:[[[NSString alloc] initWithFormat:@"%0.1f",[[[points objectAtIndex:index] objectForKey:@"y"] doubleValue]] autorelease] style:whiteText] autorelease];  
    }  
    return newLayer;  
}  



//散点数据源委托实现  
-(NSUInteger)numberOfRecordsForPlot:(CPTPlot *)plot{  
    return [points count];  
}  

-(NSNumber *)numberForPlot:(CPTPlot *)plot field:(NSUInteger)fieldEnum recordIndex:(NSUInteger) index{  
    NSString *key=(fieldEnum==CPTScatterPlotFieldX?@"x":@"y");  
    NSNumber *num=[[points objectAtIndex:index] valueForKey:key];  
   //NSLog(@"key:%@,num:%@",key,num);  
    return  num;  
}  
</code></pre>

<h3>可以在代码里看到我实现了对页面的手势监听，以便实现折线图拖动的效果，具体方法如下：</h3>

<pre><code>-(void)viewPan:(UIPanGestureRecognizer *)tapGr  
{  
    CGPoint now=[tapGr locationInView:self.view];  

//手势变化并且接近折点旁边  
if([tapGr state]==UIGestureRecognizerStateChanged&amp;&amp;[self isNearByThePoint:now]){  
    CGPoint coordinate=[self CoordinateTransformRealToAbstract:now];  
    [points removeAllObjects];  
    [reverseDic removeAllObjects];  
    NSUInteger i;  
    for(i=0;i&lt;NUM;i++){  
        id x=[NSNumber numberWithFloat:0+i];  
        id y=[NSNumber numberWithFloat:3*i+coordinate.y];  
        [reverseDic setObject:y forKey:[NSString stringWithFormat:@"%.0f",[x floatValue]]];  
        [points addObject:[NSMutableDictionary dictionaryWithObjectsAndKeys:x,@"x",y,@"y",nil]];  
    }  
    [graph reloadData];  
}  


}  

//判断手指触摸点是否在折点旁边  
-(BOOL)isNearByThePoint:(CGPoint)p{  

//从手指触摸点的实际坐标得到抽象坐标  
CGPoint abstractCoordinate=[self CoordinateTransformRealToAbstract:p];  
//获取临近坐标点  
int acX=(int)(abstractCoordinate.x+0.5);  
//判断临近坐标点是否存在折点，存在则取出  
float acY=[[reverseDic objectForKey:[NSString stringWithFormat:@"%d",acX]] floatValue];  

//构造临近坐标折点，并转化为实际屏幕坐标点  
CGPoint temp=[self CoordinateTransformAbstractToReal:CGPointMake([[NSNumber numberWithInt:acX] floatValue], acY)];  
//计算临近坐标点与手指触摸点的距离  
double distance=sqrt(pow((p.x-temp.x),2)+pow((p.y-temp.y),2));  

//NSLog(@"%f",distance);  
return distance&gt;25?NO:YES;  

}  


//空间坐标转换:实际坐标转化自定义坐标  
-(CGPoint)CoordinateTransformRealToAbstract:(CGPoint)point{  

float viewWidth=hostView.frame.size.width;  
float viewHeight=hostView.frame.size.height;  

float coordinateX=(XRANGELENGTH*point.x)/viewWidth+XRANGEBEGIN;  
float coordinateY=YRANGELENGTH-((YRANGELENGTH*point.y)/(viewHeight-GRAPAHBOTTOMPAD))+YRANGEBEGIN;  

return CGPointMake(coordinateX,coordinateY);  
}  
//空间坐标转换:自定义坐标转化实际坐标  
-(CGPoint)CoordinateTransformAbstractToReal:(CGPoint)point{  

float viewWidth=hostView.frame.size.width;  
float viewHeight=hostView.frame.size.height;  

float coordinateX=(point.x-XRANGEBEGIN)*viewWidth/XRANGELENGTH;  
float coordinateY=(-1)*(point.y-YRANGEBEGIN-YRANGELENGTH)*(viewHeight-GRAPAHBOTTOMPAD)/YRANGELENGTH;  

return CGPointMake(coordinateX,coordinateY);  

}  
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer  

{  
    return YES;  
}  
</code></pre>

<p>下面是一些常量的定义</p>

<pre><code>#define NUM 10  
//绘图空间与底部距离  
#define GRAPAHBOTTOMPAD 80.0f  

//x轴起点  
#define XRANGEBEGIN 0.0  
//x轴在屏幕可视范围内的范围  
#define XRANGELENGTH 5.0  
//y轴起点  
#define YRANGEBEGIN 0.0  
//y轴在屏幕可视范围内的范围  
#define YRANGELENGTH 100.0  


//x轴屏幕范围内大坐标间距  
#define XINTERVALLENGTH 1.0  
//x轴坐标的原点（y轴将在此与x轴相交）  
#define XORTHOGONALCOORDINATE 10.0  
//x轴每两个大坐标间小坐标个数  
#define XTICKSPERINTERVAL 2  

#define YINTERVALLENGTH 1.0  
#define YORTHOGONALCOORDINATE 1.0  
#define YTICKSPERINTERVAL 0 
</code></pre>

<p>好了，这便是iphone上怎样绘制个折线图并实现拖动效果，其实是个很简陋的例子，离真正能用还有很长的一段路要走，但先贴在这里留个记号，也许你会看到中间有些js引擎的影子，这个留在下一章再讲吧。</p>

<p><img src="http://i1001.photobucket.com/albums/af134/mxiaochi/20130607110518093_zps1865da13.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java设置编码读写文件笔记]]></title>
    <link href="http://wanax.github.io/blog/2012/11/01/javashe-zhi-bian-ma-du-xie-wen-jian-bi-ji/"/>
    <updated>2012-11-01T16:04:00+08:00</updated>
    <id>http://wanax.github.io/blog/2012/11/01/javashe-zhi-bian-ma-du-xie-wen-jian-bi-ji</id>
    <content type="html"><![CDATA[<pre><code>public class Test {  
        public static void main(String[] args) {  
            try{  
                BufferedReader br = new BufferedReader(  
                        new InputStreamReader(new FileInputStream(url),"UTF-8"));  
                String data = null;  
                StringBuffer str=new StringBuffer();  
                while((data = br.readLine())!=null)  
                {  
                    str.append(data+"\n");  
                }  
                System.out.println(str);  
                br.close();  
                Test test=new Test();  
                test.ece(str.toString());  
            }catch(Exception e){  
                e.printStackTrace();  
            }             
        }  
        public void ece(String str){  
            try{  
                BufferedWriter bw = new BufferedWriter(  
                        new OutputStreamWriter(new FileOutputStream(url,false),"UTF-8"));  
                bw.write(str);  
                bw.flush();  
                bw.close();  
            }catch(Exception e){  
                e.printStackTrace();  
            }     
        }  
}  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ajax对象数组传参方式]]></title>
    <link href="http://wanax.github.io/blog/2012/10/11/ajaxdui-xiang-shu-zu-chuan-can-fang-shi/"/>
    <updated>2012-10-11T15:53:00+08:00</updated>
    <id>http://wanax.github.io/blog/2012/10/11/ajaxdui-xiang-shu-zu-chuan-can-fang-shi</id>
    <content type="html"><![CDATA[<p>项目中一个页面需要的功能是动态添加信息列表，传至后台添加数据库。用的方式是ajax+struts2，因为struts本身的特性，在ajax的data里直接写数组名java后台是无法正常接收到的，最简单的理解便是它无法智能的一一匹配数组里的每一个值，所以我们在前台开始发action请求前便要组装好容易接收的数据格式。</p>

<p>最简单的方法是直接拼接字符串，后台split出来，但有时候用的不是简单的字符串数组而是对象数组，这时候就需要一些其它方法了。</p>

<!--more-->


<p><img src="http://i1001.photobucket.com/albums/af134/mxiaochi/blogsource/1349941967_9520_zpsbbaf2803.png" alt="image" /></p>

<p>如上图所示，每次提交是权限一个对象，然后关于资源对象是动态添加与删除的，很明显，这就需要一个对象数组来装这些东西</p>

<p>前台页面的动态添加是这样的：</p>

<pre><code>    var addNewSource = function(){  
     var htmlStr =   
      "&lt;tr class=\"sourcecontent\"&gt;"+  
               "&lt;td&gt;&lt;input class=\"sourcename\" type=\"text\"/&gt;&lt;/td&gt;&lt;td&gt;&lt;input class=\"resourceurl\" type=\"text\"/&gt;&lt;/td&gt;"+  
               "&lt;td&gt;&lt;input class=\"sourcetype\" type=\"text\"/&gt;&lt;/td&gt;&lt;td&gt;&lt;input class=\"resourcedes\" type=\"text\"/&gt;&lt;/td&gt;"+  
               "&lt;td&gt;&lt;a href=\"#\" onclick=\"deleteNewSource(this);return false;\"&gt;&lt;img class=\"deleteBtn\" src=\"&lt;%=basePath%&gt;/img/delete.png\"/&gt;&lt;/a&gt;&lt;/td&gt;"+  
            "&lt;/tr&gt;";  
         $("#resourceInfo").append(htmlStr);  

    };  
    function deleteNewSource(obj){  
     $(obj).parents('tr').remove();  
    }  
</code></pre>

<p>然后就是对对象数组的拼装与发送了</p>

<pre><code>    var xhrBeforeSend = function(){ 
        $('.status').fadeIn();
    };

    var xhrSuccess = function(data,status,xhr){
        if(data.tag=="T"){
            $('.status').css({"margin-left":"740px","color":"green"}).html("提交数据成功");
            $('.status').fadeOut(1000);
        }else{
            $('.status').css({"margin-left":"760px","color":"#FF0000"}).html("提交失败！");
        }     
    };
    KindEditor.ready(function(K) {
           K('.submitBtn').click(function() {
                        var screenWidth = $(document).width()-6;
                        var sourceList = '&lt;ul&gt;';
                        $("tr.sourcecontent").each(function(){
                            sourceList +='&lt;li&gt;'+$(this).find('.sourcename').val()+'&lt;/li&gt;';
                        });
                        sourceList +='&lt;/ul&gt;';
                        var htmlStr = '&lt;div class="dailogbox"&gt;'+
                                       '&lt;table style="width:400px; margin:10px auto;color:#ffffff;font-size:15px;"&gt;'+
                                       '&lt;tr&gt;&lt;td&gt;权限名&lt;/td&gt;&lt;td&gt;'+$("#authname").val()+'&lt;/td&gt;&lt;/tr&gt;'+
                                       '&lt;tr&gt;&lt;td&gt;权限描述&lt;/td&gt;&lt;td&gt;'+$("#authdes").val()+'&lt;/td&gt;&lt;/tr&gt;'+
                                       '&lt;tr&gt;&lt;td&gt;父级权限&lt;/td&gt;&lt;td&gt;'+$("#authparent").val()+'&lt;/td&gt;&lt;/tr&gt;'+
                                       '&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;'+
                                       '&lt;tr&gt;&lt;td&gt;关联权限:&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;'+
                                       '&lt;/table&gt;'+
                                       '&lt;div style="width:400px;margin:10px auto; color:#ffffff;"&gt;'+sourceList+ 
                                       '&lt;/div&gt;'+
                                       '&lt;/div&gt;';
                        var dialog = KindEditor.dialog({
                            width : screenWidth,
                            height: 300,
                            body  : htmlStr,
                            closeBtn : {
                                name : '关闭',
                                click : function(e) {
                                    dialog.remove();
                                }
                            },
                            yesBtn : {
                                name : '确定',
                                click : function(e) {
                                  var data = {
                                              authName:$("#authname").val(),
                                              authDes:$("#authdes").val(),
                                              authParent:$("#authparent").val()
                                   };
                                  var n=0;
                                  $("tr.sourcecontent").each(function(){
                                      data["resList[" + n + "].resourceName"] = $(this).find('.sourcename').val();
                                      data["resList[" + n + "].resourceType"] = $(this).find('.sourcetype').val();
                                      data["resList[" + n + "].resourceDescription"] = $(this).find('.sourcedes').val();
                                      data["resList[" + n + "].resourceURL"] = $(this).find('.sourceurl').val();
                                      n++;
                                  });
                                  Pager.initUrl("insertauthority.action");
                                  Pager.xhrBeforeSend=xhrBeforeSend;
                                  Pager.xhrSuccess = xhrSuccess;
                                  Pager.syncLoadData(data); 
                                  dialog.remove();
                                }
                            },
                            noBtn : {
                                name : '取消',
                                click : function(e) {
                                    dialog.remove();
                                }
                            }
                        });
                    });
         });
</code></pre>
]]></content>
  </entry>
  
</feed>
