<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tec | 陋室]]></title>
  <link href="http://wanax.github.io/blog/categories/tec/atom.xml" rel="self"/>
  <link href="http://wanax.github.io/"/>
  <updated>2013-11-14T17:30:53+08:00</updated>
  <id>http://wanax.github.io/</id>
  <author>
    <name><![CDATA[Wanax]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Octopress搭建个人博客]]></title>
    <link href="http://wanax.github.io/blog/2013/11/14/shi-yong-octopressda-jian-ge-ren-bo-ke/"/>
    <updated>2013-11-14T16:45:00+08:00</updated>
    <id>http://wanax.github.io/blog/2013/11/14/shi-yong-octopressda-jian-ge-ren-bo-ke</id>
    <content type="html"><![CDATA[<p><img src="/images/octopress-header.png" alt="image" /></p>

<p>十月份用octopress搭建了一个个人博客，现在把大概的流程介绍一下，常用的几个命令也在这里记下来。</p>

<p><a href="http://http://octopress.org/">Octopress</a>是个利用<a href="https://github.com/mojombo/jekyll">Jekyll</a>引擎开发的博客系统。它将生成的静态页面push到我们自己的github上，可以很好的在github page上展示。号称程序员博客逼格利器</p>

<blockquote><p>A blogging framework for hackers.</p></blockquote>

<!--more-->


<h3>首先是搭建发布环境</h3>

<p>Octopress需要Ruby环境，前几天自己电脑上装的Ubantu10.0自带的Ruby1.8.7试过了不行，起码要更新到Ruby1.9.1吧，官方的建议是1.9.3.</p>

<p>安装Ruby有两个方法，一个是直接去官网下载Ruby包，解压缩，安装。另一个是使用RVM(Ruby Version Manager)来负责安装和管理Ruby的环境。</p>

<p>在Mac电脑上我直接下载安装了Rvm</p>

<p><code>
curl -L https://get.rvm.io | bash -s stable --ruby
</code></p>

<p><code>
rvm install 1.9.3
rvm use 1.9.3
rvm rubygems latest
</code></p>

<p>参见<a href="http://octopress.org/docs/setup/rvm/">Installing Ruby With RVM</a></p>

<p>这样便简单搞定，但Ubantu上rvm死活搞不定，网上搜了下使用第一种方法直接安装算完了，也不麻烦。</p>

<h3>然后便是安装Octopress</h3>

<p>先把Octopress从网上down下来</p>

<p><a href="https://github.com/imathis/octopress">Octopress</a></p>

<p>电脑上有git的话简单一点</p>

<p><code>
git clone git://github.com/imathis/octopress.git octopress
</code></p>

<p>解压进入项目目录安装相关依赖</p>

<p><code>
cd octopress
gem install bundler
rbenv rehash
bundle install
</code>
参见<a href="http://octopress.org/docs/setup/">Octopress Setup</a></p>

<p>这几步是把发布Octopress的环境搞定，还没有正式开始搭建Octopress，我在Mac上发布的博客，在Ubantu从git上check下来，也要这么来一遍才能正式使用Octopress。</p>

<p>最后安装默认的Octopress 主题。</p>

<p><code>
rake install
</code></p>

<h3>接下来是配置Octopress</h3>

<p>主要是对<code>_config.yml</code>进行修改，其它的话自行研究吧。</p>

<p>具体配置参见<a href="http://octopress.org/docs/configuring/">Configuring Octopress</a>写得很详细了。</p>

<p>搞定配置后可以先大体的看下样式</p>

<p><code>
rake generate//通过引擎生成静态网页
rake preview//本地预览
</code>
<a href="localhost:4000">localhost:4000</a>进行本地预览</p>

<h3>觉得差不多了就可以把Octopress发到github上了</h3>

<p>首先需要在GitHub上创建一个仓库，并将仓库名称按照：username.github.com的方式命名。待发布完毕可以直接使用<code>http://username.github.com</code>来访问博客。同时可以把博客的源码放到source分支下，并把生成的内容提交到master分支。这样随便换到哪里的电脑上都可以check下来接着写了。</p>

<p>第一步是对我们新建的目录进行建立与初始化，会提示输入你的git的账号和密码，一次确认完毕以后你每次提交都会跑到你确认的git账号下的github.com/username/username.github.com下了。</p>

<p>本地生成一下静态Html发上去就妥了</p>

<p><code>
rake generate//生成
rake deploy//发布
</code></p>

<h3>最后说下写博客的常用命令</h3>

<p><code>
rake new_post["title"]
</code></p>

<p>这是新建一篇文章，存放在<code>source/_posts</code>目录下面，使用的是markdown语法，具体规则不麻烦，大家可以自己谷歌下。Mac下用Mou进行编辑很方便，Linux的话线上编辑会好一点，chrome有不少插件，其中一个叫Ma‘de，好像是作者用以表达对母亲的爱…</p>

<p><code>
 rake generate
 git add .
 git commit -am "Some comment here."
 git push origin source
 rake deploy
</code></p>

<p>使用上面几条命令生成与发布博客，中间的三条git命令是把博客的源码放到source的分支上，以便在不同的电脑上编辑博客。</p>

<p>参见<a href="http://octopress.org/docs/blogging/">Blogging Basics</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UICollectionView与CXPhotoBrowser配合使用示例]]></title>
    <link href="http://wanax.github.io/blog/2013/10/31/uicollectionviewyu-cxphotobrowserpei-he-shi-yong-shi-li/"/>
    <updated>2013-10-31T15:56:00+08:00</updated>
    <id>http://wanax.github.io/blog/2013/10/31/uicollectionviewyu-cxphotobrowserpei-he-shi-yong-shi-li</id>
    <content type="html"><![CDATA[<p>UICollection是在iOS6.0中新加的功能，用于图片的集中展示，大概就是图片墙的意思。基本的使用类似于UITableView，也是设置代理，数据源，对单个的Cell可以自行定制样式。稍有不同的是在UITableView中整体样式的设置只有两种，一种是Group和Plain，而在UICollection中则有较多的选择方案，具体的实现方式需要编码人员对UICollectionViewFlowLayout自行调整。</p>

<p>开发的App中有用到这种功能，结合一个台湾哥儿们Chris Xu的开源插件CXPhotoBrower，可以达到比较好的展示图片的效果。</p>

<p>具体效果图如下：</p>

<p><img src="/images/tec/uicollectionImg.png" alt="image" /></p>

<p><img src="/images/tec/cxphotobrowserImg.png" alt="image" /></p>

<p>现在开始一步步搭建吧。</p>

<!--more-->


<h3>一.备齐原料</h3>

<p>UICollection是系统自带的，这个不用关心，CXPhotoBrowser需要自行下载引入。建议使用CocoaPods进行配置，<code>pod 'CXPhotoBrowser'</code>即可，没有用过的话那进入下面的页面按指引搭建吧。</p>

<blockquote><p><a href="https://github.com/ChrisXu1221/CXPhotoBrowser">https://github.com/ChrisXu1221/CXPhotoBrowser</a></p></blockquote>

<h3>二.UICollection的使用</h3>

<h4>1.新建一个UICollectionViewController的VC</h4>

<h4>2.初始化配置UICollectionViewFlowLayout，内嵌于UICollectionViewController中对CollectionCell进行样式管理。</h4>

<p>```objc</p>

<pre><code>UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init];
/*
对四方边界与cell之间的距离进行设置，也可以通过代理设置
*/
[flowLayout setItemSize:CGSizeMake(163, 309)];
flowLayout.sectionInset = UIEdgeInsetsMake(10,15,5,15);
[flowLayout setMinimumLineSpacing:5.0];
[flowLayout setMinimumInteritemSpacing:5.0];
[flowLayout setScrollDirection:UICollectionViewScrollDirectionVertical];
self.collectionView = [[UICollectionView alloc] initWithFrame:CGRectZero collectionViewLayout:flowLayout];
//使用自定义的CollectionCell，出队列，与UITableView的思路相近
[self.collectionView registerNib:[UINib nibWithNibName:@"PicCollectionCell" bundle:nil] forCellWithReuseIdentifier:GraphExcCellIdentifier];
[self.collectionView setBackgroundColor:[Utiles colorWithHexString:@"#5b4d41"]];
self.collectionView.delegate = self;
self.collectionView.dataSource = self;
//使用开源插件进行下拉分页的功能，读者自行谷歌
[self.collectionView addInfiniteScrollingWithActionHandler:^{
    [self addPics:@"" reset:NO];
}];
self.collectionView.indicatorStyle = UIScrollViewIndicatorStyleWhite;
</code></pre>

<p>```</p>

<h4>3.CollectionCell的创建</h4>

<p>使用nib创建Cell，过程类似于tableCell，不再赘述了。</p>

<h4>4.Delegate与DataSource的设置</h4>

<p>```objc
&ndash;(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section{</p>

<pre><code>return [self.images count];
</code></pre>

<p>}
&ndash;(UICollectionViewCell <em>)collectionView:(UICollectionView </em>)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath
{</p>

<pre><code>FinanPicCollectCell *cell = (FinanPicCollectCell *)[collectionView dequeueReusableCellWithReuseIdentifier:GraphExcCellIdentifier forIndexPath:indexPath];
id model=[self.images objectAtIndex:indexPath.row];
//使用SDWebImage进行图片加载
[cell.imageView setImageWithURL:[NSURL URLWithString:[model objectForKey:@"smallImage"]]
               placeholderImage:[UIImage imageNamed:@"LOADING.png"]];
return cell;
</code></pre>

<p>}
/<em>
等同于
[flowLayout setMinimumLineSpacing:5.0];
[flowLayout setMinimumInteritemSpacing:5.0];
但可针对每个Cell单独定制
</em>/
&ndash; (CGFloat)collectionView:(UICollectionView <em>)collectionView layout:(UICollectionViewLayout</em>)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section{</p>

<pre><code>return 10.0;
</code></pre>

<p>}
&ndash; (CGFloat)collectionView:(UICollectionView <em>)collectionView layout:(UICollectionViewLayout</em>)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section{</p>

<pre><code>return 2.0;
</code></pre>

<p>}
```</p>

<h3>至此，一个基本的UICollection便简单的搭建完毕了。下面使用CXPhotoBrowser实现图片的单张浏览功能，支持左右切换与捏合放大缩小。</h3>

<h3>三.CXPhotoBrowser的使用</h3>

<p>此插件也是使用数据源代理的思路实现的，我们在载入UICollection的同时也一起对CX进行数据源的设置，另外实现两个代理方法，一个是点击单张图片获取index一遍进行此图片的放大浏览，另一个是在单张浏览功能里左右滑动时获取前后图片的index用于最上面信息栏的展示。
```objc
//pragma mark &ndash;
//pragma mark CXPhotoBrowserDelegate
//点击图片弹出详细页面
&ndash; (void)collectionView:(UICollectionView <em>)collectionView didSelectItemAtIndexPath:(NSIndexPath </em>)indexPath{</p>

<pre><code>[self.browser setInitialPageIndex:indexPath.row];
[self presentViewController:self.browser animated:YES completion:^{
}];
</code></pre>

<p>}
//左右切换视图事件
&ndash; (void)photoBrowser:(CXPhotoBrowser *)photoBrowser didChangedToPageAtIndex:(NSUInteger)index{</p>

<pre><code>[self.imageTitleLabel setText:[NSString stringWithFormat:@"%d/%d",(index+1),[self.images count]]];
</code></pre>

<p>}
//pragma mark &ndash; CXPhotoBrowserDataSource
&ndash; (NSUInteger)numberOfPhotosInPhotoBrowser:(CXPhotoBrowser *)photoBrowser
{</p>

<pre><code>return [self.photoDataSource count];
</code></pre>

<p>}
&ndash; (id <CXPhotoProtocol>)photoBrowser:(CXPhotoBrowser *)photoBrowser photoAtIndex:(NSUInteger)index
{</p>

<pre><code>if (index &lt; self.photoDataSource.count)
    return [self.photoDataSource objectAtIndex:index];
return nil;
</code></pre>

<p>}
//对上方信息栏进行设置
&ndash; (CXBrowserNavBarView <em>)browserNavigationBarViewOfOfPhotoBrowser:(CXPhotoBrowser </em>)photoBrowser withSize:(CGSize)size
{</p>

<pre><code>CGRect frame;
frame.origin = CGPointZero;
frame.size = size;
if (!navBarView)
{
    navBarView = [[CXBrowserNavBarView alloc] initWithFrame:frame];       
    [navBarView setBackgroundColor:[UIColor clearColor]];       
    UIView *bkgView = [[UIView alloc] initWithFrame:CGRectMake( 0, 0, size.width, size.height)];
    [bkgView setBackgroundColor:[UIColor blackColor]];
    bkgView.alpha = 0.2;
    bkgView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
    [navBarView addSubview:bkgView];        
    UIButton *doneButton = [UIButton buttonWithType:UIButtonTypeCustom];
    [doneButton.titleLabel setFont:[UIFont boldSystemFontOfSize:12.0]];
    [doneButton setTitle:NSLocalizedString(@"返回",@"Dismiss button title") forState:UIControlStateNormal];
    [doneButton setFrame:CGRectMake(size.width - 60, 5, 50, 30)];
    [doneButton addTarget:self action:@selector(photoBrowserDidTapDoneButton:) forControlEvents:UIControlEventTouchUpInside];
    [doneButton.layer setMasksToBounds:YES];
    [doneButton.layer setCornerRadius:4.0];
    [doneButton.layer setBorderWidth:1.0];
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGColorRef colorref = CGColorCreate(colorSpace,(CGFloat[]){ 1, 1, 1, 1 });
    [doneButton.layer setBorderColor:colorref];
    doneButton.autoresizingMask = UIViewAutoresizingFlexibleLeftMargin;
    [navBarView addSubview:doneButton];        
    self.imageTitleLabel = [[UILabel alloc] init];
    [self.imageTitleLabel setFrame:CGRectMake((size.width - 60)/2,0, 60, 40)];
    //[self.imageTitleLabel setCenter:navBarView.center];
    [self.imageTitleLabel setTextAlignment:NSTextAlignmentCenter];
    [self.imageTitleLabel setFont:[UIFont boldSystemFontOfSize:20.]];
    [self.imageTitleLabel setTextColor:[UIColor whiteColor]];
    [self.imageTitleLabel setBackgroundColor:[UIColor clearColor]];
    [self.imageTitleLabel setText:@""];
    self.imageTitleLabel.autoresizingMask = UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleRightMargin;
    [self.imageTitleLabel setTag:BROWSER_TITLE_LBL_TAG];
    [navBarView addSubview:self.imageTitleLabel];
}    
return navBarView;
</code></pre>

<p>}
//pragma mark &ndash; PhotBrower Actions
&ndash; (void)photoBrowserDidTapDoneButton:(UIButton *)sender
{</p>

<pre><code>[self dismissViewControllerAnimated:YES completion:nil];
</code></pre>

<p>}
```</p>

<h3>至此一个简答的图片墙加详细浏览的功能便做完了，欢迎交流新的想法。</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发小技巧笔记]]></title>
    <link href="http://wanax.github.io/blog/2013/10/30/ioskai-fa-xiao-ji-qiao-bi-ji/"/>
    <updated>2013-10-30T16:03:00+08:00</updated>
    <id>http://wanax.github.io/blog/2013/10/30/ioskai-fa-xiao-ji-qiao-bi-ji</id>
    <content type="html"><![CDATA[<h3>字体粗度的设置</h3>

<p><code>objc
button.titlelabel.font = [uifont boldSystemFontOfSize:xx];
</code></p>

<h3>UINavigation中间隔button的设置</h3>

<p>```objc</p>

<pre><code>UIBarButtonItem *fontListBt = [[UIBarButtonItem alloc]
                                initWithTitle:@"Font"
                                style:UIBarButtonItemStyleBordered
                                target:self
                                action:@selector(rightBtClicked:)];
UIBarButtonItem *fontSizeBt = [[UIBarButtonItem alloc]
                                 initWithTitle:@"Size"
                                 style:UIBarButtonItemStyleBordered
                                 target:self
                                 action:@selector(popoverFontSize:)];    
UIBarButtonItem *flexibleSpace = [[UIBarButtonItem alloc] 
            initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace
            target:nil
            action:nil];
self.toolBar=[[UIToolbar alloc] initWithFrame:CGRectMake(0,0,SCREEN_HEIGHT-320,44)];
[self.toolBar setItems:[NSArray arrayWithObjects:flexibleSpace,fontSizeBt,fontListBt, nil]];
[self.view addSubview:self.toolBar];
</code></pre>

<p>```</p>

<!--more-->


<h3>UILabel的圆角设置</h3>

<p>```objc</p>

<pre><code>label.layer.cornerRadius=3.0;
label.layer.borderWidth=1.0;
</code></pre>

<p>```</p>

<h3>UILabel自动换行</h3>

<p>```objc</p>

<pre><code>label.lineBreakMode=NSLineBreakByCharWrapping;
label.numberOfLines=2;
</code></pre>

<p>```</p>

<h3>UILabel行间距设置的取巧解决方案</h3>

<h4>将原本要放入的UILabel替换成同大小的UIWebView</h4>

<h4>大致思路是使用webView里内置的JS引擎解析插入的JS代码，以达到调整行间距的目的。</h4>

<h4>缺点为若嵌入在Cell中，对Cell的点击事件这一区域无法正常响应，现在的解决思路是对此webView添加独立的事件监听，达到同等目的</h4>

<p>```objc</p>

<pre><code>cell.webView.backgroundColor = [UIColor clearColor];
cell.webView.opaque = NO;
cell.webView.dataDetectorTypes = UIDataDetectorTypeNone;\
[(UIScrollView *)[[cell.webView subviews] objectAtIndex:0] setBounces:NO];//禁止webView的滚动
//16px/18px:前者为行间距，后者为字体大小
NSString *webviewText = @"&lt;style&gt;body{margin:0;color:#967c6c;background-color:transparent;font:16px/18px Custom-Font-Name}&lt;/style&gt;";
NSString *htmlString = [webviewText stringByAppendingFormat:@"%@", str];
[cell.webView loadHTMLString:htmlString baseURL:nil];
</code></pre>

<p>```</p>

<h3>URL路径的UTF-8转码</h3>

<h4>在一些通过url路径显示图片的页面中，会出现部分图片无法正常显示的问题。有一种可能是抓包分析可以看出这些无法正常显示的图片的url中有中文字体的嵌入，这便涉及到了URL转码的问题，可根据具体的字体编码设置进行转码，大致code如下</h4>

<p><code>objc
NSURL *url = [NSURL URLWithString:[strUrl stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]];
</code></p>

<h3>获取文本的长宽尺寸</h3>

<p>```objc
CGSize constraint = CGSizeMake(CELL_CONTENT_WIDTH &ndash; (CELL_CONTENT_MARGIN * 2), 20000.0f);<br/>
NSDictionary * attributes = [NSDictionary dictionaryWithObject:[UIFont systemFontOfSize:FONT_SIZE] forKey:NSFontAttributeName];
NSAttributedString *attributedText =[[NSAttributedString alloc]</p>

<pre><code>                                     initWithString:text
                                     attributes:attributes];                                         
</code></pre>

<p>CGRect rect = [attributedText boundingRectWithSize:constraint</p>

<pre><code>                            options:NSStringDrawingUsesLineFragmentOrigin
                            context:nil];
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala在Mac下的安装方法]]></title>
    <link href="http://wanax.github.io/blog/2013/10/25/scalazai-macxia-de-an-zhuang-fang-fa/"/>
    <updated>2013-10-25T14:36:00+08:00</updated>
    <id>http://wanax.github.io/blog/2013/10/25/scalazai-macxia-de-an-zhuang-fang-fa</id>
    <content type="html"><![CDATA[<h3>第一种方法</h3>

<p>1.访问scala的官网<a href="http://www.scala-lang.org/">这里</a>下载最新版的scala。</p>

<p>2.解压缩文件包，可将其移动至<code>/usr/local/share</code>下</p>

<p><code>
mv /download/scalapath /usr/local/share
</code></p>

<p>3.修改环境变量，在mac下使用<code>sudo su</code>进入管理员权限，修改配置文件profile，</p>

<p><code>
vim /etc/profile
</code></p>

<p>在文件的末尾加入</p>

<p><code>
export PATH="$PATH:/usr/local/share/scala/bin"
</code></p>

<p><code>:wq!</code>保存退出，重启终端，完成scala的配置安装。</p>

<h3>第二种方法</h3>

<p>如果本机有安装Ruby的话则安装更加简单，可以借助Homebrew进行安装。
首先安装Homebrew</p>

<blockquote><p>ruby -e “$(curl -fsSL <a href="https://raw.github.com/mxcl/homebrew/go">https://raw.github.com/mxcl/homebrew/go</a>)”</p></blockquote>

<p>再进行scala的安装<code>brew install scala</code></p>

<p>大功告成~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIView三种动画笔记]]></title>
    <link href="http://wanax.github.io/blog/2013/06/09/uiviewsan-chong-dong-hua-bi-ji/"/>
    <updated>2013-06-09T10:30:00+08:00</updated>
    <id>http://wanax.github.io/blog/2013/06/09/uiviewsan-chong-dong-hua-bi-ji</id>
    <content type="html"><![CDATA[<p>``` objc
[UIView animateWithDuration:0.6f</p>

<pre><code>    delay:0  
    options:UIViewAnimationOptionCurveEaseOut  
    animations:^{  
       self.view.alpha = 0;  
    }  
    completion:^(BOOL finished) {  
       [self.view removeFromSuperview];  
</code></pre>

<p>}];<br/>
```
  <!--more--></p>

<p>``` objc</p>

<pre><code>[UIView beginAnimations:@"animation" context:nil];  
[UIView setAnimationDuration:0.8f];  
[UIView setAnimationCurve:UIViewAnimationCurveEaseOut];  
[UIView setAnimationTransition:UIViewAnimationTransitionCurlDown forView:delegate.tabBarController.view cache:YES];  
[UIView commitAnimations];
</code></pre>

<p>```</p>

<p>```objc</p>

<pre><code>CATransition *animation = [CATransition animation];  
animation.duration = 0.8f;  
animation.timingFunction = UIViewAnimationCurveEaseInOut;  
animation.fillMode = kCAFillModeForwards;  
animation.type = kCATransitionMoveIn;   
animation.subtype = kCATransitionFromBottom;  
[[self.view layer] addAnimation:animation forKey:@"animation"];  
animation=nil; 
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
